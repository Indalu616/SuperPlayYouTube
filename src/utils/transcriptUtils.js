// Utility functions for fetching and processing YouTube video transcripts

/**
 * Extract video ID from YouTube URL
 */
export function extractVideoId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/watch\?.*v=([^&\n?#]+)/
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }
  
  return null;
}

/**
 * Get current video ID from the page
 * Only works in content script context, not service worker
 */
export function getCurrentVideoId() {
  if (typeof window === 'undefined') {
    throw new Error('getCurrentVideoId can only be called from content script context');
  }
  const url = window.location.href;
  return extractVideoId(url);
}

/**
 * Fetch video transcript using YouTube's internal caption API
 * Attempts multiple methods to get transcript data
 */
export async function fetchVideoTranscript(videoId) {
  try {
    console.log('Fetching transcript for video:', videoId);
    
    // Method 1: Try to get transcript from YouTube's player response
    const transcript = await tryGetTranscriptFromPlayerResponse(videoId);
    if (transcript) {
      return cleanTranscript(transcript);
    }

    // Method 2: Try to get auto-generated captions
    const autoTranscript = await tryGetAutoGeneratedCaptions(videoId);
    if (autoTranscript) {
      return cleanTranscript(autoTranscript);
    }

    // Method 3: Fallback to extracting from page if available
    const pageTranscript = tryExtractFromPage();
    if (pageTranscript) {
      return cleanTranscript(pageTranscript);
    }

    // If all methods fail, throw error
    throw new Error('No transcript available for this video');
    
  } catch (error) {
    console.error('Failed to fetch transcript:', error);
    throw new Error('Unable to fetch video transcript: ' + error.message);
  }
}

/**
 * Try to get transcript from YouTube's player response API
 */
async function tryGetTranscriptFromPlayerResponse(videoId) {
  try {
    // YouTube's internal API endpoint for getting video info
    const response = await fetch(`https://www.youtube.com/youtubei/v1/player?key=KEY_HERE`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        context: {
          client: {
            clientName: 'WEB',
            clientVersion: '2.20230101.00.00'
          }
        },
        videoId: videoId
      })
    });

    if (!response.ok) {
      throw new Error('Failed to fetch player response');
    }

    const data = await response.json();
    
    // Extract captions from the response
    const captions = data?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captions || !captions.length) {
      return null;
    }

    // Prefer English captions, or take the first available
    let captionTrack = captions.find(track => 
      track.languageCode?.toLowerCase() === 'en' || 
      track.languageCode?.toLowerCase() === 'en-us'
    ) || captions[0];

    if (!captionTrack?.baseUrl) {
      return null;
    }

    // Fetch the actual transcript content
    const transcriptResponse = await fetch(captionTrack.baseUrl);
    if (!transcriptResponse.ok) {
      return null;
    }

    const transcriptXml = await transcriptResponse.text();
    return parseTranscriptXml(transcriptXml);

  } catch (error) {
    console.log('Player response method failed:', error.message);
    return null;
  }
}

/**
 * Try to get auto-generated captions using a different approach
 */
async function tryGetAutoGeneratedCaptions(videoId) {
  try {
    // This method tries to extract caption tracks from the video page
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`);
    if (!response.ok) {
      return null;
    }

    const html = await response.text();
    
    // Look for caption tracks in the page HTML
    const captionRegex = /"captionTracks":\s*(\[.*?\])/;
    const match = html.match(captionRegex);
    
    if (!match) {
      return null;
    }

    const captionTracks = JSON.parse(match[1]);
    
    if (!captionTracks || !captionTracks.length) {
      return null;
    }

    // Get the first available caption track
    const captionTrack = captionTracks[0];
    
    if (!captionTrack.baseUrl) {
      return null;
    }

    // Fetch the transcript
    const transcriptResponse = await fetch(captionTrack.baseUrl);
    if (!transcriptResponse.ok) {
      return null;
    }

    const transcriptXml = await transcriptResponse.text();
    return parseTranscriptXml(transcriptXml);

  } catch (error) {
    console.log('Auto-generated captions method failed:', error.message);
    return null;
  }
}

/**
 * Try to extract transcript from the current page if captions are enabled
 * Only works in content script context, not service worker
 */
function tryExtractFromPage() {
  try {
    // Check if we're in a service worker context
    if (typeof document === 'undefined') {
      console.log('Page extraction method skipped: not in content script context');
      return null;
    }

    // Look for subtitle elements that might be present on the page
    const subtitleElements = document.querySelectorAll('.ytp-caption-segment');
    
    if (subtitleElements.length > 0) {
      return Array.from(subtitleElements)
        .map(el => el.textContent?.trim())
        .filter(text => text)
        .join(' ');
    }

    // Alternative: look for transcript in the description or comments
    const description = document.querySelector('#description-text, #description');
    if (description) {
      const text = description.textContent;
      // Simple heuristic: if description is long and contains time stamps, it might be a transcript
      if (text.length > 500 && /\d{1,2}:\d{2}/.test(text)) {
        return text;
      }
    }

    return null;

  } catch (error) {
    console.log('Page extraction method failed:', error.message);
    return null;
  }
}

/**
 * Parse XML transcript format from YouTube
 */
function parseTranscriptXml(xml) {
  try {
    // Check if DOMParser is available (service workers in Chrome do support it)
    if (typeof DOMParser === 'undefined') {
      console.log('DOMParser not available, falling back to regex parsing');
      return parseTranscriptXmlFallback(xml);
    }

    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');
    const textElements = doc.querySelectorAll('text');
    
    if (!textElements.length) {
      return parseTranscriptXmlFallback(xml);
    }

    return Array.from(textElements)
      .map(el => {
        // Decode HTML entities and clean up text
        const text = el.textContent || '';
        return text
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .trim();
      })
      .filter(text => text)
      .join(' ');

  } catch (error) {
    console.error('Failed to parse transcript XML:', error);
    return parseTranscriptXmlFallback(xml);
  }
}

/**
 * Fallback XML parsing using regex when DOMParser is not available
 */
function parseTranscriptXmlFallback(xml) {
  try {
    // Extract text content using regex
    const textMatches = xml.match(/<text[^>]*>([^<]*)<\/text>/g);
    
    if (!textMatches) {
      return null;
    }

    return textMatches
      .map(match => {
        // Extract content between tags
        const content = match.replace(/<text[^>]*>([^<]*)<\/text>/, '$1');
        // Decode HTML entities
        return content
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .trim();
      })
      .filter(text => text)
      .join(' ');

  } catch (error) {
    console.error('Failed to parse transcript XML with fallback:', error);
    return null;
  }
}

/**
 * Clean and process transcript text
 */
export function cleanTranscript(rawTranscript) {
  if (!rawTranscript) return '';
  
  return rawTranscript
    // Remove excessive whitespace
    .replace(/\s+/g, ' ')
    // Remove timestamp markers (common patterns)
    .replace(/\d{1,2}:\d{2}(?::\d{2})?\s*/g, '')
    // Remove common YouTube auto-caption artifacts
    .replace(/\[Music\]/gi, '')
    .replace(/\[Applause\]/gi, '')
    .replace(/\[Laughter\]/gi, '')
    .replace(/\[.*?\]/g, '')
    // Clean up punctuation
    .replace(/\s+([.,!?])/g, '$1')
    .trim();
}

/**
 * Chunk transcript into smaller pieces for AI processing
 */
export function chunkTranscript(transcript, maxChunkSize = 2000) {
  if (!transcript || transcript.length <= maxChunkSize) {
    return [transcript];
  }

  const chunks = [];
  const sentences = transcript.split(/[.!?]+/);
  let currentChunk = '';

  for (const sentence of sentences) {
    const trimmedSentence = sentence.trim();
    if (!trimmedSentence) continue;

    if (currentChunk.length + trimmedSentence.length + 1 <= maxChunkSize) {
      currentChunk += (currentChunk ? '. ' : '') + trimmedSentence;
    } else {
      if (currentChunk) {
        chunks.push(currentChunk + '.');
      }
      currentChunk = trimmedSentence;
    }
  }

  if (currentChunk) {
    chunks.push(currentChunk + '.');
  }

  return chunks;
}

/**
 * Format timestamp from seconds to MM:SS format
 */
export function formatTimestamp(seconds) {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

/**
 * Parse timestamp string to seconds
 */
export function parseTimestamp(timestamp) {
  const parts = timestamp.split(':').map(Number);
  
  if (parts.length === 2) {
    return parts[0] * 60 + parts[1]; // MM:SS
  } else if (parts.length === 3) {
    return parts[0] * 3600 + parts[1] * 60 + parts[2]; // HH:MM:SS
  }
  
  return 0;
}

/**
 * Check if captions are available for the video
 * Only works in content script context, not service worker
 */
export function areCaptionsAvailable() {
  if (typeof document === 'undefined') {
    console.log('areCaptionsAvailable: not available in service worker context');
    return false;
  }
  
  // Check for YouTube's caption button
  const captionButton = document.querySelector('.ytp-subtitles-button');
  return captionButton && !captionButton.classList.contains('ytp-button-disabled');
}

/**
 * Get video duration in seconds
 * Only works in content script context, not service worker
 */
export function getVideoDuration() {
  if (typeof document === 'undefined') {
    console.log('getVideoDuration: not available in service worker context');
    return 0;
  }
  
  const video = document.querySelector('video');
  return video ? video.duration : 0;
}

/**
 * Get video title
 * Only works in content script context, not service worker
 */
export function getVideoTitle() {
  if (typeof document === 'undefined') {
    console.log('getVideoTitle: not available in service worker context');
    return 'Unknown Video';
  }
  
  const titleElement = document.querySelector('#title h1.ytd-watch-metadata');
  return titleElement ? titleElement.textContent.trim() : 'Unknown Video';
}

/**
 * Validate video ID format
 */
export function isValidVideoId(videoId) {
  return /^[a-zA-Z0-9_-]{11}$/.test(videoId);
}
